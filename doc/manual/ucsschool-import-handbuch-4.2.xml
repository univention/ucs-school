<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE book [
	<!ENTITY % extensions SYSTEM "../stylesheets/macros.ent" >
	<!ENTITY % DocBookDTD PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
	<!ENTITY % entities SYSTEM "../stylesheets/macros-de.ent" >
	%extensions;
	%DocBookDTD;
	%entities;
]>
<book lang="de" id="ucsschool-4.2-import">
	<bookinfo>
		<title>
			&ucsUAS;
		</title>
		<subtitle>
			Handbuch Import-Schnittstelle
		</subtitle>
		<legalnotice>
			<literallayout>
				Version 4.2 v4
				Stand: 11. Oktober 2017
			</literallayout>
			<literallayout lang="">
				Alle Rechte vorbehalten./ All rights reserved.
				(c) 2017
				Univention GmbH
				Mary-Somerville-Straße 1
				28359 Bremen
				Deutschland
				feedback@univention.de
			</literallayout>
			<para>
				Jede aufgeführte Marke und jedes Warenzeichen steht im Eigentum ihrer jeweiligen eingetragenen Rechtsinhaber.
				Linux ist ein eingetragenes Warenzeichen von Linus Torvalds.
			</para>
			<para lang="en">
				The mentioned brand names and registered trademarks are owned by the respective legal owners in each case.
				Linux is a registered trademark of Linus Torvalds.
			</para>
		</legalnotice>
	</bookinfo>

	<chapter id="audience">
		<title>Zielgruppe</title>
		<para>
			Dieses Handbuch richtet sich an Administratoren und Programmierer. Die Import Software ist im Auslieferungszustand stark konfigurierbar, kann aber zusätzlich programmatisch erweitert werden. In diesem Handbuch werden der Ablauf eines Importvorganges, Konfigurationsoptionen und Programmierschnittstellen beschrieben.
		</para>
	</chapter>

	<chapter id="introduction">
		<title>Einführung</title>
		<para>
			&ucsUAS; bringt
			für viele regelmäßig wiederkehrende Verwaltungsaufgaben Werkzeuge und Schnittstellen
			mit. Die Übernahme von Benutzerdaten aus der Schulverwaltung ist eine dieser wiederkehrenden
			Aufgaben, die über die neue Importschnittstelle für Benutzer automatisiert erledigt werden kann.
		</para>
		<para>
			Der &ucsUAS; Import ermöglicht es Benutzerdaten aus einer Datei auszulesen, die Daten zu normieren, automatisch eindeutige Benutzernamen und E-Mail-Adressen zu generieren und notwendige Änderungen (Hinzufügen/Modifizieren/Löschen) automatisch zu erkennen.
			Er wurde so konzipiert, dass die Konten einer UCS Domäne automatisch mit dem Datenbestand eines vorhandenen Benutzerverzeichnisses abgeglichen werden können.
		</para>
		<para>
			Die Importschnittstelle ist darauf ausgelegt, mit möglichst geringem Aufwand an die
			unterschiedlichen Gegebenheiten in Schulen angepasst zu werden.  So ist die Basis der
			Importschnittstelle bereits vorbereitet, um unterschiedliche Dateiformate einlesen zu
			können. &ucsUAS; bringt einen Importfilter für CSV-Dateien mit, der für unterschiedlichste
			CSV-Formate konfiguriert werden kann.
		</para>
		<para>
			Über eigene Python-Plugins kann die Schnittstelle erheblich erweitert werden. Dies
			umfasst sowohl die Unterstützung für zusätzliche Dateiformate als auch die Implementierung von
			zusätzlichen Automatismen, die während des Imports greifen.
		</para>
		<para>
			In den nachfolgenden Kapiteln werden der Ablauf eines Imports, die unterschiedlichen
			Konfigurationsmöglichkeiten sowie die Erweiterungsmöglichkeiten der Schnittstelle um neue
			Funktionalitäten beschrieben.
		</para>
	</chapter>

	<chapter id="procedure">
		<title>Ablauf des Importvorgangs</title>
		<para>
			Die Importschnittstelle wurde als ein kommandozeilenbasiertes Tool umgesetzt, welches darauf ausgelegt ist, einen
			automatischen, nicht-interaktiven Import durchzuführen. Um dies zu erreichen, müssen bestimmte Voraussetzungen erfüllt
			werden, die in diesem Abschnitt anhand des Importablaufes erläutert werden.
		</para>
		<para>
			Das Tool wurde in der Skriptsprache Python implementiert und ist in der Lage, zusätzliche/kundenspezifische Python-Dateien
			zu laden, die ein abweichendes Verhalten oder zusätzliche Funktionalitäten der Importschnittstelle hinzufügen.
		</para>
		<para>
			Der Ablauf eines automatischen Imports wird über die nachfolgenden Schritte skizziert:
			<orderedlist>
				<listitem>
					<simpara>
						Die zu übernehmenden Benutzerdaten müssen automatisch oder manuell aus dem Quellverzeichnis exportiert und als Datei gespeichert werden.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Für den Import muss vorab einmalig eine Konfigurationsdatei erstellt werden, die bei jedem weiteren Import wiederverwendet werden kann.
						Die Konfigurationsdatei ermöglicht es dem Importtool <command>ucs-school-user-import</command>, die exportierten Daten einzulesen und die Eingabedatensätze (Benutzerdaten) konkreten &ucsUAS;-Benutzern im LDAP-Verzeichnisdienst zuzuordnen.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Die Importschnittstelle unterstützt zwei unterschiedliche Modi, die festlegen, ob die Eingabedatensätze als neuer Soll-Zustand oder als inkrementelles Update zum Ist-Zustand interpretiert werden sollen.
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								Im ersten Fall werden die Eingabedatensätze als neuer Soll-Zustand verwendet. Dazu wird ein automatischer Abgleich zwischen den &ucsUAS;-Benutzern im
								LDAP-Verzeichnisdienst und den übergebenen Eingabedatensätzen durchgeführt, um zu ermitteln, welche &ucsUAS;-Benutzer im LDAP-Verzeichnisdienst angelegt, modifiziert
								oder gelöscht werden müssen, um den neuen Soll-Zustand zu erreichen.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Im zweiten Fall findet kein automatischer Abgleich statt. Stattdessen muss bei jedem Eingabedatensatz speziell vermerkt werden, ob der dazu passenden &ucsUAS;-Benutzer im
								LDAP-Verzeichnis angelegt, modifiziert oder gelöscht werden. Dieser teilautomatische Ansatz erfordert erheblich mehr Prozesslogik bei der Bereitstellung der Eingabedatensätze,
								da die entsprechenden Teile in der Importschnittstelle deaktiviert sind.
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<simpara>
						Je nach Konfiguration werden die Werte des Eingabedatensatzes nach dem Einlesen automatisch geprüft, modifiziert und/oder erweitert. Darunter fällt z.B. auch die automatische Zuweisung eines eindeutigen Benutzernamens oder die Generierung einer E-Mail-Adresse.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Während des vollständigen Einlesens und Verarbeitens der Eingabedatensätze werden noch keine Änderungen am LDAP-Verzeichnis vorgenommen.
						Sind alle Eingabedatensätze verarbeitet, werden im Anschluss die notwendigen Änderungen am LDAP-Verzeichnis durchgeführt: &ucsUAS;-Benutzer werden gelöscht, verändert oder angelegt.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Neuen &ucsUAS;-Benutzern werden während des Imports automatisch sichere, zufällige Passwörter zugeteilt.
						Da Passwörter im LDAP-Verzeichnis grundsätzlich nicht im Klartext vorliegen und somit später nicht mehr ausgelesen werden können,
						werden die Passwörter für neue Benutzer, sofern explizit konfiguriert, in einer speziellen CSV-Datei abgelegt.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Nach den erfolgten Änderungen am LDAP-Verzeichnis wird abschließend ein Bericht in Form einer CSV-Datei erzeugt, mit dessen Hilfe sich schnell die Eingabedaten
						und die durch sie verursachten Änderungen sowie eventuell aufgetretene Probleme nachvollziehen lassen.
					</simpara>
				</listitem>
			</orderedlist>
		</para>
		<para>
			<figure id="procedure_import">
				<title>Ablauf eines Benutzerimports</title>
				<graphic scalefit="1" width="95%" align="center" fileref="illustrations42/import_ablauf.png"/>
			</figure>
			Für die Analyse von Problemen wird während des gesamten Imports ein Protokoll über alle technischen Vorgänge in Logdateien mit unterschiedlichen Detailtiefen geführt.
			Wenn nicht anders konfiguriert, sind das die Dateien <filename>/var/log/univention/ucs-school-import.log</filename> und <filename>/var/log/univention/ucs-school-import.info</filename>.
		</para>

		<section id="procedure:fileformat">
			<title>Datenformate</title>
			<para>
				Die Importsoftware kann gegenwärtig Daten nur aus <ulink url="https://de.wikipedia.org/wiki/CSV_(Dateiformat)"><citetitle>CSV-Dateien</citetitle></ulink> einlesen. Wie eine Unterstützung für weitere Dateiformate (z.B. JSON, XML etc.) hinzugefügt werden kann, kann dem <xref linkend="extending"/> entnommen werden.
			</para>
		</section>
		<section id="procedure:assignment">
			<title>Zuordnung von Benutzern des Quellverzeichnisses zu &ucsUAS;-Benutzern</title>
			<para>
			  Das Tool <command>ucs-school-user-import</command> unterstützt den Import von Benutzerdaten aus mehreren Quellverzeichnissen. Um jeden &ucsUAS;-Benutzer einem Benutzer in einer Quelldatenbank eindeutig zuordnen zu können, werden am UCS@school-Benutzerobjekt zwei zusätzliche Attribute gespeichert: <property>sourceUID</property> und <property>recordUID</property>.
			</para>
			<para>
				Die <property>sourceUID</property> ist ein eindeutiger Bezeichner für die Quelldatenbank von der ein Benutzer importiert wurde. Der Bezeichner kann frei gewählt werden und muss für jede Quelldatenbank eindeutig sein. Er ist während des Imports auf der Kommandozeile bzw. in der Konfigurationsdatei für jede Quelldatenbank explizit mit anzugeben.
			</para>
			<para>
				Die <property>recordUID</property> ist ein eindeutiger Bezeichner für den Benutzer in der Quelldatenbank. Als Bezeichner kann z.B. auf vorhandene Attribute innerhalb der Quelldatenbank, wie z.B. eine Schüler- oder Mitarbeiternummer, zurückgegriffen werden. Sollte kein eindeutig identifizierendes Attribut in der Quelldatenbank vorhanden sein, kann auch durch die Konkatenation von mehreren Attributen der Quelldatenbank ein ein eindeutiger Bezeichner generiert werden.
			</para>
			<para>
				Durch die Kombination dieser beiden Bezeichner kann ein &ucsUAS;-Benutzer genau einem Benutzer in einem bestimmten Quellverzeichnis zugeordnet werden.
			</para>
			<caution>
				<para>
					<property>sourceUID</property> und <property>recordUID</property> müssen eindeutig und unveränderlich sein, sonst werden &ucsUAS;-Benutzer beim Abgleich mit den Eingabedaten nicht gefunden und ggf. gelöscht bzw. es werden die falschen &ucsUAS;-Benutzerobjekte modifiziert.
				</para>
			</caution>

			<para>
				Mit Hilfe der beiden Bezeichner <property>sourceUID</property> und <property>recordUID</property> wird versucht, jeden Eingabedatensatz genau einem &ucsUAS;-Benutzer zuzuordnen:
				<itemizedlist>
					<listitem>
						<simpara>
							Wurde kein &ucsUAS;-Benutzer mit passenden Bezeichnern im LDAP-Verzeichnis gefunden, wird ein neuer &ucsUAS;-Benutzer auf Basis des Eingabedatensatzes erstellt.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Existiert ein passender &ucsUAS;-Benutzer bereits, wird er von <command>ucs-school-user-import</command> modifiziert.
							Die Importsoftware gleicht die Eingabedaten mit dem LDAP-Verzeichnisdienst ab und passt den &ucsUAS;-Benutzer entsprechend dem Eingabedatensatz an.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Während des Abgleichs wird auch geprüft, ob im LDAP-Verzeichnis &ucsUAS;-Benutzer der betreffenden Quelldatenbank vorhanden sind, die in den Eingabedatensätzen nicht mehr vorhanden sind.
							Die betroffenen &ucsUAS;-Benutzer werden dann automatisch gelöscht.
						</simpara>
					</listitem>
				</itemizedlist>
			</para>
			<caution>
				<para>
					Wird vom früheren Import Skript zum Neuen migriert muss beachtet werden, dass je nachdem welche Version zuvor benutzt wurde, an den Benutzerobjekten entweder <emphasis>keine</emphasis> <property>sourceUID</property> gespeichert wurde, oder der Wert <literal>LegacyDB</literal>.
				</para>
			</caution>
			<para>
				Beispiele:
				<itemizedlist>
					<listitem>
						<para>
							Die Schulen eines Schulträgers verwenden voneinander unabhängige Verwaltungssoftware. Die Software exportiert für jede Schule separate CSV-Dateien für den Import. Es wird je eine Datei für Schüler, Lehrer und Mitarbeiter erzeugt.
							Für den Import der CSV-Dateien wird pro Schule und Benutzerrolle eine separate Konfiguration mit individueller <property>sourceUID</property> benötigt.
							Sind die Konfigurationen hinreichend ähnlich, können die gleichen Konfigurationsdateien verwendet werden und die sie unterscheidenden Optionen an der Kommandozeile gesetzt werden. Sollten sich nur <property>sourceUID</property> und Benutzerrolle unterschieden, so würde der Import mit den entsprechenden Optionen z.B. so aufgerufen:
							<programlisting>
 # /usr/share/ucs-school-import/scripts/ucs-school-user-import \
    --conffile &lt;gemeinsame Konfigurationsdatei&gt; \
    --sourceUID &lt;Schulname&gt;-&lt;Benutzerrolle&gt; \
    --user_role &lt;Benutzerrolle&gt; \
    --infile &lt;CSV-Datei&gt;
							</programlisting>
							Durch die Verwendung von <replaceable>Schulname-Benutzerrolle</replaceable> (z.B. <literal>GSMitte-student</literal>) als <property>sourceUID</property> wird ein eindeutiger Bezeichner pro Schule und Benutzerrolle sicher gestellt.
						</para>
						<simpara>
							Ab &ucsUAS; Version 4.2 v4 wird nur eine <property>sourceUID</property> pro Schule benötigt (<replaceable>-&lt;Benutzerrolle&gt;</replaceable> kann weggelassen werden), sofern mit <option>--user_role</option> die Benutzerrolle angegeben wird.
						</simpara>
						<simpara>
							In diesem Szenario ist die Verwendung schulübergreifender Benutzerkonten <emphasis>nicht</emphasis> möglich, weil dafür eine gemeinsame  <property>sourceUID</property> der beteiligten Schulen benötigt wird.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Ein Schulträger verwendet eine Software für die Verwaltung aller seiner Schulen. Die Software exportiert für jede Benutzerrolle eine CSV-Datei. In diesen Dateien sind alle Benutzer aller Schulen (von der jeweiligen Rolle) enthalten.
							Für den Import der CSV-Dateien wird nur pro Benutzerrolle eine separate Konfiguration mit individueller <property>sourceUID</property> benötigt, bzw. die gleiche Konfigurationsdatei und an der Kommandozeile wird gesetzt: <literal>--sourceUID &lt;Benutzerrolle&gt;</literal>.
						</simpara>
						<simpara>
							Ab &ucsUAS; Version 4.2 v4 wird keine separate <property>sourceUID</property> mehr pro Benutzerrolle benötigt. Es reicht dann eine Konfigurationsdatei mit einer darin eingespeicherten <property>sourceUID</property> für alle Importvorgänge, sofern mit <option>--user_role</option> die Benutzerrolle angegeben wird.
						</simpara>
						<simpara>
							In diesem Szenario ist die Verwendung schulübergreifender Benutzerkonten möglich, weil Benutzer mit der gleichen Rolle an allen Schulen die gleiche <property>sourceUID</property> haben.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Ein Schulträger verwendet eine Software für die Verwaltung aller seiner Schulen. Die Software exportiert alle Benutzer in eine CSV-Datei. In dieser Datei sind Benutzer aller Rollen und aller Schulen enthalten. In der CSV-Datei gibt es eine Spalte in der steht welche Rolle der jeweilige Benutzer hat.
							Für den Import der CSV-Dateien wird nur eine Konfigurationsdatei mit einer darin eingespeicherten <property>sourceUID</property> benötigt. Um die Benutzerrolle auszulesen muss die Klasse zum Einlesen von CSV-Dateien abgeleitet und erweitert werden: <classname>ucsschool.importer.reader.csv_reader.CsvReader</classname>. Ein Code-Beispiel findet sich in der Klasse <classname>ucsschool.importer.reader.test_csv_reader.TestCsvReader</classname>, zu welcher die Konfigurationsdatei <filename>/usr/share/ucs-school-import/configs/ucs-school-testuser-import.json</filename> gehört.
						</simpara>
						<simpara>
							In diesem Szenario ist die Verwendung schulübergreifender Benutzerkonten möglich, weil alle Benutzer die gleiche <property>sourceUID</property> haben.
						</simpara>
					</listitem>
				</itemizedlist>
			</para>
			<para>
			</para>
		</section>
	</chapter>

	<chapter id="configuration">
	<title>Konfiguration</title>
		<para>
			Die Konfiguration des Imports wird über Dateien im <ulink url="https://de.wikipedia.org/wiki/JavaScript_Object_Notation"><citetitle>JSON-Format</citetitle></ulink> und Kommandozeilenparameter gesteuert.
			Alle Kommandozeilenparameter können als Variablen in den Konfigurationsdateien verwendet werden, so dass ein Ausführen der Importsoftware ohne Kommandozeilenparameter möglich ist.
			Es ist aber auch möglich, über Kommandozeilenparameter sämtliche Variablen, die in Konfigurationsdateien stehen, zu überschreiben.
		</para>
		<para>
			Beim Start von <command>ucs-school-user-import</command> werden nacheinander mehrere Konfigurationsdateien eingelesen.
			Jede Datei fügt der Konfiguration neue Konfigurationsvariablen hinzu oder überschreibt bereits existierende Konfigurationsvariablen von vorher eingelesenen Konfigurationsdateien.
		</para>
		<para>
			Die Konfiguration des Imports wird in der folgenden Reihenfolge (mit aufsteigender Priorität) über folgende Konfigurationsdateien und Kommandozeilenparameter eingelesen:
			<orderedlist>
				<listitem>
					<simpara>
						<filename>/usr/share/ucs-school-import/configs/global_defaults.json</filename> (Diese Datei sollte nicht manuell editiert werden!)
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<filename>/var/lib/ucs-school-import/configs/global.json</filename> (Diese Datei kann manuell angepasst werden &ndash; siehe unten)
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<filename>/usr/share/ucs-school-import/configs/user_import_defaults.json</filename> (Diese Datei sollte nicht manuell editiert werden!)
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<filename>/var/lib/ucs-school-import/configs/user_import.json</filename> (Diese Datei kann manuell angepasst werden &ndash; siehe unten)
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Eine JSON-Datei, die mit dem Parameter <option>-c</option> an der Kommandozeile angegeben wurde.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Variablen, die über den Kommandozeilenparameter <option>--set</option> gesetzt wurden.
					</simpara>
				</listitem>
			</orderedlist>
		</para>
		<para>
			Die Konfigurationsdateien unterhalb von <filename class="directory">/usr/share/ucs-school-import/configs/</filename> sollten nicht editiert werden. Sie sind Teil der &ucsUAS;-Installation und werden u.U. von Updates überschrieben.
		</para>
		<para>
			Die Dateien unter <filename class="directory">/var/lib/ucs-school-import/configs/</filename> werden automatisch bei der Installation angelegt und sind eigens dafür vorgesehen, eigene Einstellungen bzw. Konfigurationen vorzuhalten. Die Dateien bleiben bei Updates unangetastet.
		</para>
		<para>
			Folgendes Verfahren wird empfohlen:
			<orderedlist>
				<listitem>
					<simpara>
						Um Variablen zu überschreiben, die in <filename>/usr/share/ucs-school-import/configs/global_defaults.json</filename> gesetzt werden, können eigene Werte in die Datei <filename>/var/lib/ucs-school-import/configs/global.json</filename> eingetragen werden.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Um Variablen zu überschreiben, die in <filename>/usr/share/ucs-school-import/configs/user_import_defaults.json</filename> gesetzt werden, können eigene Werte in die Datei <filename>/var/lib/ucs-school-import/configs/user_import.json</filename> eingetragen werden. Falls regelmäßig aus mehreren Quellverzeichnissen Benutzer importiert werden, sollten in dieser Datei auch Variablen gesetzt werden, die für alle Datenquellen gleichermaßen gelten.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Pro Quellverzeichnis sollte eine Konfigurationsdatei unterhalb von <filename class="directory">/var/lib/ucs-school-import/configs/</filename> abgelegt werden, welche schließlich an der Kommandozeile mit <option>-c</option> angegeben wird. Diese Datei enthält Konfigurationseinstellungen, die auf die Spezifika der jeweiligen Schule bzw. Schulverwaltungssoftware einzugehen, und die jeweilige <property>sourceUID</property> passend zum Quellverzeichnis.
					</simpara>
				</listitem>
			</orderedlist>
		</para>
		<para>
			Die resultierende Konfiguration, die sich aus eingelesenen Konfigurationsdateien sowie verwendete Kommandozeilenparameter zusammenstellt, wird am Anfang jedes Importlaufes angezeigt und in alle Protokolldateien geschrieben. Um eine Konfiguration zu testen, kann ein Probelauf mit <option>--dry-run</option> gestartet (und jederzeit gefahrlos abgebrochen) werden. Der Parameter simuliert einen Import, ohne dass Änderungen am &ucsUAS;-Benutzern vorgenommen werden.
		</para>

		<section id="configuration:cmdline_parameters">
			<title>Kommandozeilenparameter</title>
			<programlisting>
# /usr/share/ucs-school-import/scripts/ucs-school-user-import --help
usage: ucs-school-user-import [-h] [-c CONFFILE] [-i INFILE]
                [-l LOGFILE] [-m] [-n] [-s SCHOOL]
                [--set [KEY=VALUE [KEY=VALUE ...]]]
                [--sourceUID sourceUID] [-u USER_ROLE] [-v]
optional arguments:
  -h, --help            show this help message and exit
  -c CONFFILE, --conffile CONFFILE
            Configuration file to use (see
            /usr/share/doc/ucs-school-import for an
            explanation on configuration file stacking).
  -i INFILE, --infile INFILE
            CSV file with users to import (shortcut for
            --set input:filename=...).
  -l LOGFILE, --logfile LOGFILE
            Write to additional logfile (shortcut for
            --set logfile=...).
  --set [KEY=VALUE [KEY=VALUE ...]]
            Overwrite setting(s) from the configuration file. Use ':' in
            key to set nested values (e.g. 'scheme:email=...').
  -m, --no-delete
            Only add/modify given user objects. User objects not
            mentioned within input files are not deleted/deactived
            (shortcut for --set no_delete=...) [default: False].
  -n, --dry-run
            Dry run - don't actually commit changes to LDAP (shortcut
            for --set dry_run=...) [default: False].
  --sourceUID sourceUID
            The ID of the source database (shortcut for
            --set sourceUID=...) [mandatory either here or in the
            configuration file].
  -s SCHOOL, --school SCHOOL
            Name of school. Set only, if the source data does not
            contain the name of the school and all users are from one
            school (shortcut for --set school=...) [default: None].
  -u USER_ROLE, --user_role USER_ROLE
            Set this, if the source data contains users with only one
            role &lt;student|staff|teacher|teacher_and_staff&gt;
            (shortcut for --set user_role=...) [default: None].
  -v, --verbose
            Enable debugging output on the console [default: False].
			</programlisting>
			<para>
				Nahezu alle Kommandozeilenparameter können auch in den Konfigurationsdateien angegeben werden. Um Variablen aus Konfigurationsdateien an der Kommandozeile zu setzen, kann <option>--set</option> verwendet werden. Geschachtelte Konfigurationsvariablen können mit dem Doppelpunkt angegeben werden.
			</para>
			<para>
				Um z.B. "2" als die Anzahl der Kopfzeilen in einer CSV-Datei anzugeben, kann entweder in einer  Konfigurationsdatei stehen:
				<programlisting>
{
    "csv": {
        "header_lines": 2
    }
}
				</programlisting>
			</para>
			<para>
				oder es kann an der Kommandozeile der folgende Parameter verwendet werden:
				<programlisting>
--set csv:header_lines=2
				</programlisting>
			</para>
			<para>
				Alle Zuweisungen für Variablen können leerzeichengetrennt hinter dem Kommandozeilenparameter <option>--set</option> aufgelistet werden. Dabei ist zu beachten, dass nur ein <option>--set</option>-Parameter an der Kommandozeile ausgewertet wird.
				<programlisting>
--set csv:header_lines=2 maildomain=univention.de no_delete=True
				</programlisting>
			</para>
		</section>

		<section id="configuration:json_format">
			<title>JSON-Konfigurationsformat</title>
			<para>
				Das JSON-Format erlaubt Daten in verschachtelten Strukturen zu speichern, und ist sowohl von Computern als auch Menschen zuverlässig zu lesen und zu schreiben.
				Nach dem Editieren einer JSON-Datei kann ihre syntaktische Korrektheit mit Hilfe einer Webseite zur JSON Validierung oder eines Kommandozeilenprogramms überprüft werden:
				<programlisting>
python -m json.tool &lt; my_config.json
				</programlisting>
			</para>
			<para>
				Im Folgenden werden alle Konfigurationsschlüssel und ihre möglichen Werte und Typen beschrieben.
			</para>
			<para>
				Schlüssel sind immer als Zeichenketten (<classname>string</classname>) zu behandeln und müssen in doppelten Anführungszeichen stehen.
				Als Datentypen werden folgende Typen unterstützt: Wahrheitswerte (<classname>boolean</classname>: <literal>true</literal> / <literal>false</literal>), Ganzzahlen (<classname>int</classname>), Gleitkommazahlen (<classname>float</classname>), Listen (<classname>list</classname>: Werte die in <literal>[</literal> und <literal>]</literal> eingeschlossen sind) und Objekte (<classname>object</classname>: neue Verschachtelungsebene die in <literal>{</literal> und <literal>}</literal> eingeschlossen wird).
				Die Verschachtelungstiefe wird in den Schlüsseln wie oben beschrieben mit Doppelpunkten angezeigt.
			</para>
			<note>
				<simpara>
					Eine Kurzreferenz aller Konfigurationsschlüssel findet sich auf dem Domänencontroller Master im Verzeichnis <filename class="directory">/usr/share/doc/ucs-school-import/</filename>.
				</simpara>
			</note>
			<section id="configuration:json_format:global">
				<title>Globale Konfiguration</title>
				<caution>
					<simpara>
						In den folgenden Tabellen kommt es layoutbedingt zu Leerzeichen und Umbrüchen in Variablen- und Schlüsselnamen.
						 Diese müssen in den Konfigurationsdateien bzw. an der Kommandozeile entfernt werden.
						<emphasis>Keines</emphasis> der Schlüsselwörter enthält ein Leerzeichen oder einen Schrägstrich.
					</simpara>
				</caution>
				<table id="table:global_configuration">
					<title>Globale Konfigurationsoptionen</title>
					<tgroup cols="2">
						<colspec colnum="1" colname="key" colwidth="1*"/>
						<colspec colnum="2" colname="description" colwidth="4*"/>
						<thead>
							<row>
								<entry>Schlüssel / Kommandozeilenparameter</entry>
								<entry>Beschreibung</entry>
							</row>
						</thead>
						<tbody>
<!-- dry_run -->
							<row>
								<entry morerows="1" id="configuration:json_format:global:dry_run"><literallayout><varname>dry_run</varname>
<option>-n</option>
<option>--dry-run</option></literallayout></entry>
								<entry>Ob ein Testlauf gestartet werden soll. Es werden keine Änderungen vorgenommen.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>boolean</classname>): <literal>false</literal></entry>
							</row>
<!-- logfile -->
							<row>
								<entry morerows="1" id="configuration:json_format:global:logfile"><literallayout><varname>logfile</varname>
<option>-l</option>
<option>--logfile</option></literallayout></entry>
								<entry>Datei in die das ausführliche Protokoll geschrieben werden soll. Es wird außerdem eine Datei die auf <literal>.info</literal> endet, mit weniger technischen Details, angelegt.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"/var/log/univention/ucs-school-import.log"</literal></entry>
							</row>
<!-- verbose -->
							<row>
								<entry morerows="1"><literallayout><varname>verbose</varname>
<option>-v</option>
<option>--verbose</option></literallayout></entry>
								<entry>Ob ein ausführliches Protokoll auf die Kommandozeile geschrieben werden soll.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>boolean</classname>): <literal>true</literal></entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</section>

			<section id="configuration:json_format:userimport">
				<title>Konfiguration des Benutzerimports</title>
				<table id="table:userimport_configuration">
					<title>Konfigurationsoptionen für den Benutzerimport</title>
					<tgroup cols="2">
						<colspec colnum="1" colname="key" colwidth="1*"/>
						<colspec colnum="2" colname="description" colwidth="4*"/>
						<thead>
							<row>
								<entry>Schlüssel</entry>
								<entry>Beschreibung</entry>
							</row>
						</thead>
						<tbody>
<!-- classes -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:classes"><varname>classes</varname></entry>
								<entry>Die Methoden der Klasse <classname>DefaultUserImportFactory</classname> können überschrieben werden ohne die Klasse selbst zu ändern. Die Namen der überschriebenen Methoden ohne vorangestelltes <methodname>make_</methodname> sind die Schlüssel, der volle Python-Pfad der Wert. Standardmäßig ist das Objekt leer und die Klasse DefaultUserImportFactory wird unverändert verwendet. Ein Beispiel findet sich in <xref linkend="extending:subclassing:overwriting_factory_method"/>.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{}</literal></entry>
							</row>
<!-- factory -->
							<row>
								<entry morerows="1"><varname>factory</varname></entry>
								<entry>Voller Python-Pfad zu einer Klasse die von <classname>DefaultUserImportFactory</classname> abgeleitet ist. Wenn gesetzt, wird sie an ihrer Stelle verwendet (siehe <xref linkend="extending:subclassing:replacing_factory_class"/>).</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"ucsschool.importer.default_user_import_factory. DefaultUserImportFactory"</literal></entry>
							</row>
<!-- input -->
							<row>
								<entry morerows="1"><varname>input</varname></entry>
								<entry>Objekt, welches Informationen über die Eingabedaten enthält.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>)</entry>
							</row>
<!-- input:type -->
							<row>
								<entry morerows="1"><varname>input:type</varname></entry>
								<entry>Datenformat der angegebenen Eingabedatei. &ucsUAS; unterstützt derzeit nur "csv" als Datenformat.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"csv"</literal></entry>
							</row>
<!-- input:filename -->
							<row>
								<entry morerows="1"><literallayout><varname>input:filename</varname>
<option>-i</option>
<option>--infile</option></literallayout></entry>
								<entry>Einzulesende Datei.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"/var/lib/ucs-school-import/new-format-userimport.csv"</literal></entry>
							</row>
<!-- activate_new_users -->
							<row>
								<entry morerows="1"><varname>activate_new \ _users</varname></entry>
								<entry>Objekt, welches Konfigurationsmöglichkeiten zur Benutzeraktivierung enthält. Standardmäßig ist im Objekt nur der Schlüssel <literal>default</literal> gesetzt. Weitere Schlüssel (<literal>student</literal>, <literal>staff</literal>, <literal>teacher</literal>, <literal>teacher_and_staff</literal>) sind möglich (siehe <xref linkend="configuration:default_key"/>).</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{"default": ..}</literal></entry>
							</row>
<!-- activate_new_users:default -->
							<row>
								<entry morerows="1"><varname>activate_new \ _users: \ default</varname></entry>
								<entry>Diese Variable definiert, ob ein neuer Benutzer automatisch aktiviert werden soll. Ist <literal>false</literal> eingestellt, wird das Benutzerkonto beim Anlegen automatisch deaktiviert.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>boolean</classname>): <literal>true</literal></entry>
							</row>
<!-- csv -->
							<row>
								<entry morerows="1"><varname>csv</varname></entry>
								<entry>Dieses Objekt enthält Informationen darüber, wie CSV-Eingabedaten interpretiert werden sollen.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{"header_lines": .., "incell-delimiter": .., "mapping": ..}</literal></entry>
							</row>
<!-- csv:delimiter -->
							<row>
								<entry morerows="1"><varname>csv:delimiter</varname></entry>
								<entry>Diese Variable definiert das Trennzeichen zwischen zwei Spalten. Als Wert wird üblicherweise ein Komma, Semikolon oder Tabulator verwendet. Die Importschnittstelle versucht das Trennzeichen automatisch zu erkennen, wenn diese Variable nicht gesetzt ist.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): nicht gesetzt</entry>
							</row>
<!-- csv:header_lines -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:csv:header_lines"><varname>csv:header_ \ lines</varname></entry>
								<entry>Diese Variable definiert, wie viele Zeilen der Eingabedaten übersprungen werden sollen, bevor die eigentlichen Benutzerdaten anfangen. Wird der Wert "1" (Kopfdatensatz) verwendet, wird der Inhalt der ersten Zeile als Namen der einzelnen Spalten interpretiert. Die dort verwendeten Namen können dann in <link linkend="configuration:json_format:userimport:csv:mapping"><literal>csv:mapping</literal></link> als Schlüssel verwendet werden.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>int</classname>): <literal>1</literal></entry>
							</row>
<!-- csv:incell-delimiter -->
							<row>
								<entry morerows="1"><varname>csv:incell- \ delimiter</varname></entry>
								<entry>Dieses Objekt enthält Informationen darüber, welches Zeichen <emphasis>innerhalb</emphasis> einer Zelle zwei Daten trennt und kann z.B. bei der Angabe von mehreren Telefonnummern verwendet werden. Es kann ein Standard (<literal>default</literal>) und  pro &ucsUDM;-Attribut eine Konfiguration (mit dem Namen des Schlüssels in <link linkend="configuration:json_format:userimport:csv:mapping"><literal>csv:mapping</literal></link>) definiert werden.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{"default": ..}</literal></entry>
							</row>
<!-- csv:incell-delimiter:default -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:csv:incell-delimiter:default"><varname>csv:incell- \ delimiter: \ default</varname></entry>
								<entry>Standard-Trennzeichen <emphasis>innerhalb</emphasis> einer Zelle, wenn kein spezieller Schlüssel für die Spalte existiert.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>","</literal></entry>
							</row>
<!-- csv:mapping -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:csv:mapping"><varname>csv:mapping</varname></entry>
								<entry>Enthält Informationen über die Zuordnung von CSV-Spalten zum Benutzerobjekt. Ist standardmäßig leer. Siehe <xref linkend="configuration:mapping"/>.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{}</literal></entry>
							</row>
<!-- deletion_grace_period -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:deletion_grace_period"><varname>deletion_grace_period</varname></entry>
								<entry>Dieses Objekt enthält Einstellungen zum Löschen von Benutzern.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{"deactivation": .., "deletion": ..}</literal></entry>
							</row>
<!-- deletion_grace_period:deactivation -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:deletion_grace_period:deactivation"><varname>deletion_grace_period: \ deactivation</varname></entry>
								<entry>Definiert in wie vielen Tagen ein Benutzer, der nicht mehr in den Eingabedaten enthalten ist, deaktiviert (nicht gelöscht) werden soll. Wenn <literal>0</literal> gesetzt ist, wird das betroffene &ucsUAS;-Benutzerkonto sofort deaktiviert. Wenn <link linkend="configuration:json_format:userimport:deletion_grace_period:deletion"><literal>deletion_grace_period:deletion</literal></link> auf einen kleineren oder den gleichen Wert gesetzt ist, wird das Benutzerobjekt gelöscht statt deaktiviert.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>int</classname>): <literal>0</literal></entry>
							</row>
<!-- deletion_grace_period:deletion -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:deletion_grace_period:deletion"><varname>deletion_grace_period: \ deletion</varname></entry>
								<entry>Definiert die Anzahl der Tage, die nach dem Import vergehen sollen, bevor der Benutzer gelöscht aus dem Verzeichnisdienst wird. Bei einem Wert von <literal>0</literal> wird der Benutzer sofort gelöscht. Bei größeren Zahlen wird das geplante Löschdatum im &ucsUDM;-Attribut <property>ucsschoolPurgeTimestamp</property> gesetzt. Ein Cron Job löscht automatisch Benutzer, deren geplanter Löschzeitpunkt erreicht ist.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>int</classname>): <literal>0</literal></entry>
							</row>
<!-- scheme -->
							<row>
								<entry morerows="1"><varname>scheme</varname></entry>
								<entry><simpara>Enthält Informationen über die Erzeugung von Werten aus anderen Werten und Regeln.</simpara><simpara>Es können Ersetzungen wie in den <ulink url="http://docs.software-univention.de/handbuch-4.2.html#users:templates"><citetitle>UCS-Benutzervorlagen</citetitle></ulink> verwendet werden sowie alle Schlüssel aus <link linkend="configuration:json_format:userimport:csv:mapping"><literal>csv:mapping</literal></link>. Neben Formatvorlagen für <property>email</property>, <property>recordUID</property> und <property>username</property> können Konfigurationen für beliebige &ucsUDM;-Attribute hinterlegt werden. <literal>[ALWAYSCOUNTER]</literal> und <literal>[COUNTER2]</literal> werden <emphasis>nur</emphasis> in <varname>scheme:email</varname> und <varname>scheme:username</varname> verarbeitet.</simpara></entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{"email": .., "recordUID": .., "username": {..}}</literal></entry>
							</row>
<!-- scheme:email -->
							<row>
								<entry morerows="1"><varname>scheme:email</varname></entry>
								<entry>Schema aus dem die Email-Adresse erzeugt werden soll. Zusätzlich zu den in <xref linkend="configuration:scheme_formatting"/> beschriebenen Ersetzungen kommen noch zwei weitere hinzu: <literal>[ALWAYSCOUNTER]</literal> und <literal>[COUNTER2]</literal> (siehe <xref linkend="configuration:unique_usernames_and_email"/>).</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"&lt;firstname&gt;[0].&lt;lastname&gt;@&lt;maildomain&gt;"</literal></entry>
							</row>
<!-- scheme:recordUID -->
							<row>
								<entry morerows="1"><varname>scheme: \ recordUID</varname></entry>
								<entry>Schema aus dem die eindeutige ID des Benutzers in der Quelldatenbank (Schulverwaltungssoftware) erzeugt werden soll.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"&lt;email&gt;"</literal></entry>
							</row>
<!-- scheme:username -->
							<row>
								<entry morerows="1"><varname>scheme: \ username</varname></entry>
								<entry>Enthält Informationen über die Erzeugung von Benutzernamen. Standardmäßig enthält das Objekt nur die Schlüssel <literal>allow_rename</literal> und <literal>default</literal>. Weitere Schlüssel (<literal>student</literal>, <literal>staff</literal>, <literal>teacher</literal>, <literal>teacher_and_staff</literal>) sind möglich (siehe <xref linkend="configuration:default_key"/>). Zusätzlich zu den in <xref linkend="configuration:scheme_formatting"/> beschriebenen Ersetzungen kommen noch zwei weitere hinzu: <literal>[ALWAYSCOUNTER]</literal> und <literal>[COUNTER2]</literal> (siehe <xref linkend="configuration:unique_usernames_and_email"/>).</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{"allow_rename": .., "default": ..}</literal></entry>
							</row>
<!-- scheme:username:allow_rename -->
							<row>
								<entry morerows="1"><varname>scheme: \ username: \ allow_rename</varname></entry>
								<entry>Definiert, ob das Ändern von Benutzernamen erlaubt sein soll. Diese Variable ist z.Z. ohne Funktion.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>boolean</classname>): <literal>false</literal></entry>
							</row>
<!-- scheme:username:default -->
							<row>
								<entry morerows="1"><varname>scheme: \ username: \ default</varname></entry>
								<entry>Schema aus dem der Benutzername erzeugt werden soll, wenn kein Schema speziell für diesen Benutzertyp existiert.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"&lt;:umlauts&gt;&lt;firstname&gt;[0].&lt;lastname&gt;[COUNTER2]"</literal></entry>
							</row>
<!-- scheme:<udm attribute name> -->
							<row>
								<entry morerows="1"><varname>scheme:&lt;udm attribute name&gt;</varname></entry>
								<entry>&ucsUDM;-Attribute, die aus einem Schema erzeugt werden sollen. Der Schlüssel braucht nicht in <link linkend="configuration:json_format:userimport:csv:mapping"><literal>csv:mapping</literal></link> vorzukommen.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): nicht gesetzt</entry>
							</row>
<!-- maildomain -->
							<row>
								<entry morerows="1"><varname>maildomain</varname></entry>
								<entry>Der Wert dieser Variable wird beim Formatieren mit einem Schema in die Variable <varname>&lt;maildomain&gt;</varname> eingesetzt. Wenn nicht gesetzt, wird versucht <varname>&lt;maildomain&gt;</varname> durch Daten aus dem System zu füllen.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): nicht gesetzt</entry>
							</row>
<!-- mandatory_attributes -->
							<row>
								<entry morerows="1"><varname>mandatory_ \ attributes</varname></entry>
								<entry>Liste mit &ucsUDM; Attributnamen, die während des Imports aus den Eingabedaten oder indirekt über ein Schema gesetzt werden müssen.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>list</classname>): <literal>["firstname", "lastname", "name", "school"]</literal></entry>
							</row>
<!-- no_delete -->
							<row>
								<entry morerows="1"><literallayout><varname>no_delete</varname>
<option>-m</option>
<option>--no-delete</option></literallayout></entry>
								<entry>Wenn auf <literal>true</literal> gesetzt, werden keine Benutzer gelöscht, oder nur solche für die es in den Eingabedaten <emphasis>explizit</emphasis> vermerkt ist. Dies kann genutzt werden, um eine Änderung an &ucsUAS;-Benutzern vorzunehmen, ohne einen vollständigen Soll-Zustand zu übergeben oder um neue Benutzer hinzuzufügen..</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>bool</classname>): <literal>false</literal></entry>
							</row>
<!-- output -->
							<row>
								<entry morerows="1"><varname>output</varname></entry>
								<entry>Dieses Objekt enthält Informationen über zu produzierende Dokumente.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): <literal>{"import_summary": ..}</literal></entry>
							</row>
<!-- output:new_user_passwords -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:output:new_user_passwords"><varname>output:new_ \ user_passwords</varname></entry>
								<entry>Diese Variable definiert den Pfad zur CSV-Datei, in die Passwörter neuer Benutzer geschrieben werden. Auf den Dateinamen wird die Python-Funktion <methodname>datetime.datetime.strftime()</methodname> angewandt. Wenn ein <ulink url="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior"><citetitle><foreignphrase>Python-Format-String</foreignphrase></citetitle></ulink> in ihm vorkommt, wird dieser umgewandelt (siehe Beispiel <link linkend="configuration:json_format:userimport:output:user_import_summary"><literal>output:user_import_summary</literal></link>).</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): nicht gesetzt</entry>
							</row>
<!-- output:user_import_summary -->
							<row>
								<entry morerows="1" id="configuration:json_format:userimport:output:user_import_summary"><varname>output:user_ \ import_summary</varname></entry>
								<entry>Diese Variable definiert den Pfad zur CSV-Datei, in die eine Zusammenfassung des Import-Vorganges geschrieben wird. Auf den Dateinamen wird, wie bei <link linkend="configuration:json_format:userimport:output:new_user_passwords"><literal>output:new_user_passwords</literal></link>, die Python-Funktion <methodname>datetime.datetime.strftime()</methodname> angewandt.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): <literal>"/var/lib/ucs-school-import/user_import_summary_%Y-%m-%d_%H:%M:%S.csv"</literal></entry>
							</row>
<!-- password_length -->
							<row>
								<entry morerows="1"><varname>password_ \ length</varname></entry>
								<entry>Definiert die Länge des zufälligen Passwortes, das für neue Benutzer erzeugt wird.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>int</classname>): <literal>15</literal></entry>
							</row>
<!-- school -->
							<row>
								<entry morerows="1"><literallayout><varname>school</varname>
<option>-s</option>
<option>--school</option></literallayout></entry>
								<entry>Schulkürzel/OU-Name der Schule, für die der Import sein soll. Dieser Wert gilt für alle Benutzer in den Eingabedaten. Sollte nur gesetzt werden, wenn die Schule nicht über die Eingabedaten gesetzt wird.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): nicht gesetzt</entry>
							</row>
<!-- >sourceUID -->
							<row>
								<entry morerows="1"><literallayout><varname>sourceUID</varname>
<option>--sourceUID</option></literallayout></entry>
								<entry>Eindeutige und unveränderliche Kennzeichnung der Datenquelle.
Muss zwingend entweder in einer Konfigurationsdatei oder an der Kommandozeile gesetzt werden.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): nicht gesetzt</entry>
							</row>
<!-- tolerate_errors -->
							<row>
								<entry morerows="1"><varname>tolerate_ \ errors</varname></entry>
								<entry>Definiert die Anzahl an (für die Import-Software) nicht-kritischen Fehlern, die toleriert werden sollen, bevor der Import abgebrochen wird. Wird der Wert <literal>-1</literal> verwendet, bricht der Import nicht ab und fährt mit dem nächsten Eingabedatensatz fort.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>int</classname>): <literal>0</literal></entry>
							</row>
<!-- user_deletion -->
							<row>
								<entry morerows="1"><varname>user_deletion</varname></entry>
								<entry>Veraltet. Bitte <link linkend="configuration:json_format:userimport:deletion_grace_period"><literal>deletion_grace_period</literal></link> verwenden.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>object</classname>): nicht gesetzt</entry>
							</row>
<!-- user_role -->
							<row>
								<entry morerows="1"><literallayout><varname>user_role</varname>
<option>-u</option>
<option>--user_role</option></literallayout></entry>
								<entry>Definiert die Benutzerrolle für alle Eingabedatensätze. Diese Variable sollte nur gesetzt werden, wenn die Benutzerrolle nicht in den Eingabedaten enthalten ist und die Eingabedatensätze homogen alle die gleiche Benutzerrolle verwenden sollen. Erlaubte Werte sind <literal>student</literal>, <literal>staff</literal>, <literal>teacher</literal> und <literal>teacher_and_staff</literal>.</entry>
							</row>
							<row>
								<entry align="right">Standard (<classname>string</classname>): nicht gesetzt</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</section>
		</section>

		<section id="configuration:default_key">
			<title>"default"-Schlüssel</title>
			<para>
				Einige Einstellungen erlauben das Setzen von verschiedenen Werten, je nach Rolle des Benutzers, der gerade importiert wird.
				In einem solchen Fall gibt es immer den Schlüssel <literal>default</literal>, der automatisch verwendet wird, wenn es keinen Schlüssel in der Konfiguration für die betroffene Benutzerrolle gibt.
				Erlaubte Werte für die Benutzerrollen-Schlüssel sind <literal>student</literal>, <literal>staff</literal>, <literal>teacher</literal> und <literal>teacher_and_staff</literal>.
			</para>
			<para>
				Es müssen nicht zwangsläufig Schlüssel für alle Benutzerrollen angegeben werden.
				Gilt für eine Einstellung z.B. das gleiche für Mitarbeiter und Lehrer und weicht nur der Wert für die Schüler-Benutzerrolle ab, so reicht es aus, <literal>default</literal> und <literal>student</literal> zu konfigurieren. In den Fällen <literal>staff</literal>, <literal>teacher</literal> und <literal>teacher_and_staff</literal> wird in Abwesenheit einer spezifischen Konfiguration automatisch auf <literal>default</literal> zurückgefallen:
				<programlisting>
{
    "scheme": {
        "username": {
            "default": "&lt;:umlauts&gt;&lt;firstname&gt;[0].&lt;lastname&gt;[COUNTER2]",
            "student": "&lt;:umlauts&gt;&lt;firstname&gt;.&lt;lastname&gt;&lt;:lower&gt;[ALWAYSCOUNTER]"
        }
    }
}
				</programlisting>
			</para>
		</section>

		<section id="configuration:mapping">
			<title>Zuordnung von Eingabedaten zu Benutzerattributen</title>
			<para>
				Während des Imports aus einer CSV-Datei müssen die Daten einer Zeile, Attributen des anzulegenden bzw. zu ändernden Benutzerobjekts zugeordnet werden.
				Diese Zuordnung geschieht im Konfigurationsobjekt <link linkend="configuration:json_format:userimport:csv:mapping"><literal>csv:mapping</literal></link>.
				In ihm stehen Schlüssel-Wert-Paare: CSV-Spalte &rarr; Benutzerattribut.
			</para>
			<para>
				Folgendes Beispiel zeigt wie der Import von drei Schülern an zwei Schulen konfiguriert werden kann.
				Die Schulverwaltungssoftware hat folgendes CSV produziert:
				<programlisting>
"Schulen","Vorname","Nachname","Klassen","Mailadresse","phone"
"schule1,schule2","Anton","Meyer","schule1-1A,schule2-2B","anton@schule.local",""
"schule1,schule2","Bea","Schmidt","schule1-2B,schule2-1A","bea@schule.local","0421-1234567890"
"schule2","Daniel","Krause","schule2-1A","daniel@schule.local",""
				</programlisting>
			</para>
			<para>
				Als erstes fällt auf, dass ein Schüler an zwei Schulen gleichzeitig eingeschrieben ist.
				Schulübergreifende Benutzerkonten wurden mit &ucsUAS; 4.1R2 eingeführt (siehe <ulink url="https://docs.software-univention.de/release-notes-ucsschool-4.1R2v1-de.html"><citetitle>UCS@school 4.1 R2 v1 Release Notes</citetitle></ulink>) und werden von der Importsoftware unterstützt.
				Entsprechend sind die Namen der Klassen so kodiert, dass sie eindeutig einer Schule zugeordnet werden können.
				Anton geht also in die Klasse <literal>1A</literal> der Schule <literal>Schule1</literal> und in die Klasse <literal>2B</literal> der Schule <literal>Schule2</literal>.
			</para>
			<para>
				Die Namen der Schulen bzw. Klassen sind ohne Leerzeichen und durch Komma getrennt, aufgelistet.
				Als Trennzeichen innerhalb einer CSV-Zelle wird das Komma verwendet, da dies implizit aus der Standardeinstellung <link linkend="configuration:json_format:userimport:csv:incell-delimiter:default"><literal>csv:incell-delimiter:default=","</literal></link> aus <filename>/usr/share/ucs-school-import/configs/user_import_defaults.json</filename> übernommen wurde.
			</para>
			<para>
				Folgende Konfiguration nutzt implizit die Standardeinstellung <link linkend="configuration:json_format:userimport:csv:header_lines"><literal>csv:header_lines=1</literal></link> aus <filename>/usr/share/ucs-school-import/configs/user_import_defaults.json</filename> und verwendet damit die Spaltennamen aus der CSV-Kopfzeile als Schlüssel.
				<programlisting>
{
    "csv": {
        "mapping": {
            "Schulen": "schools",
            "Vorname": "firstname",
            "Nachname": "lastname",
            "Klassen": "school_classes",
            "Mailadresse": "email",
            "phone": "phone"
        }
    }
}
				</programlisting>
			</para>
			<para>
				Um die Konfiguration zu überprüfen kann ein Testlauf mit <link linkend="configuration:json_format:global:dry_run"><option>--dry-run</option></link> gestartet werden. Anschließend steht in <filename>/var/log/univention/ucs-school-import.log</filename> ein <link linkend="configuration:json_format:global:logfile">Protokoll</link> das Debug-Ausgaben enthält. Hier findet sich:
				<programlisting>
2016-06-28 17:47:25 INFO  user_import.read_input:81  ------ Starting to read users from input data... ------
[..]
2016-06-28 17:47:25 DEBUG base_reader.next:73  Input 3: ['schule1', 'Bea', 'Schmidt', 'schule1-2B,schule2-1A',
'bea@schule.local', 'Sch\xc3\xbclerin mit Telefon', '0421-1234567890'] -> {u'Schulen': u'schule1',
u'Vorname': u'Bea', u'phone': u'0421-1234567890', u'Nachname': u'Schmidt', u'Klassen': u'schule1-2B,schule2-1A',
u'Mailadresse': u'bea@schule.local'}
				</programlisting>
			</para>
			<para>
				Ab der zweiten Zeile ist dies folgendermaßen zu lesen:
				<itemizedlist>
					<listitem>
						<simpara>
							<literal>Input 3</literal>: dritte Zeile der Eingabedatei, die Kopfzeile mitgerechnet.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							<literal>['schule1', 'Bea', 'Schmidt', 'schule1-2B,schule2-1A', 'bea@schule.local', '0421-1234567890']</literal>: Die Eingabezeile mit bereits getrennten Spalten.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							<literal>{u'Schulen': u'schule1', u'Vorname': u'Bea', u'phone': u'0421-1234567890', u'Nachname': u'Schmidt', u'Klassen': u'schule1-2B,schule2-1A', u'Mailadresse': u'bea@schule.local'}</literal>: Die Zuordnung von Daten zu den Schlüsseln aus der CSV-Kopfzeile.
						</simpara>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Das Einlesen aus der CSV-Datei ist gelungen.
				Die Daten wurden den Schlüsseln aus der CSV-Kopfzeile zugeordnet.
				Da diese in <link linkend="configuration:json_format:userimport:csv:mapping"><varname>csv:mapping</varname></link> verwendet werden, kann nun weiter unten, beim Anlegen der Benutzer, die Zuordnung der Daten zu Benutzerattributen beobachtet werden:
				<programlisting>
2016-06-28 17:47:25 INFO  user_import.create_and_modify_users:107  ------ Creating / modifying users... ------
[..]
2016-06-28 17:47:25 INFO  user_import.create_and_modify_users:128  Adding ImportStudent(name='B.Schmidt',
school='schule1', dn='uid=B.Schmidt,cn=schueler,cn=users,ou=schule1,dc=uni,dc=dtr', old_dn=None) (source_uid:NewDB
record_uid:bea@schule.local) attributes={'$dn$': 'uid=B.Schmidt,cn=schueler,cn=users,ou=schule1,dc=uni,dc=dtr',
'display_name': 'Bea Schmidt', <property>'record_uid'</property>: u'bea@schule.local', 'firstname': 'Bea',
'lastname': 'Schmidt', 'type_name': 'Student', 'school': 'schule1', <property>'name'</property>: 'B.Schmidt',
'disabled': 'none', 'email': u'bea@schule.local', 'birthday': None, 'type': 'importStudent', 'schools': ['schule1'],
'password': 'xxxxxxxxxx', 'source_uid': u'NewDB', <property>'school_classes'</property>: {'schule1': ['schule1-2B'],
'schule2': ['schule2-1A']}, 'objectType': 'users/user'} <property>udm_properties</property>={u<property>'phone'</property>: [u'0421-1234567890'],
'overridePWHistory': '1', 'overridePWLength': '1'}...
				</programlisting>
			</para>
			<para>
				Hier ist nun zu sehen, dass Daten umgewandelt und Attributen zugeordnet wurden, sowie dass einige Attribute aus anderen Daten generiert wurden:
				<itemizedlist>
					<listitem>
						<simpara>
							<property>school_classes</property> ist von einer kommaseparierten Liste zu einer Datenstruktur geworden.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							<property>name</property> und <property>record_uid</property> sind aus den konfigurierten Schemata <varname>scheme:username</varname> und <varname>scheme:recordUID</varname> erzeugt worden.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							<property>phone</property> wurde in einem <property>udm_properties</property> genannten Objekt gespeichert.
						</simpara>
					</listitem>
				</itemizedlist>
			</para>
			<note>
				<para>
					In <property>udm_properties</property> werden Daten am Benutzerobjekt gespeichert, die nicht zu den Attributen der <classname>ImportUser</classname> Klasse gehören (siehe <xref linkend="extending:import_user_class"/>).
					Die Schlüssel entsprechen der Ausgabe des Kommandos:
					<programlisting>
udm users/user
					</programlisting>
				</para>
			</note>
			<para>
				Bei der obigen, langen Ausgabe handelt es sich um die Beschreibung eines <link linkend="extending:import_user_class"><classname>ImportUser</classname></link> Objektes.
				Dieses zu kennen wird wichtig für die Programmierung von Hooks (siehe <xref linkend="extending:hooks"/>), mit denen vor und nach dem Anlegen, Ändern oder Löschen von Benutzern noch Aktionen ausgeführt werden können.
			</para>
			<para>
				Es existieren zwei "Sonderwerte" die in der Konfiguration der Zuordnung (<link linkend="configuration:json_format:userimport:csv:mapping"><varname>mapping</varname></link>) verwendet werden können: <literal>__action</literal> und <literal>__ignore</literal>:
				<itemizedlist>
					<listitem>
						<simpara>
							<literal>__action</literal>: Steht in einer CSV-Spalte immer die auf einen eingelesenen Benutzer anzuwendende Aktion als Buchstabe kodiert, so wird die Import-Software keine eigene Entscheidung darüber fällen, sondern dieser Anweisung folgen.
						</simpara>
						<simpara>
							Anlegen (<foreignphrase>add</foreignphrase>): <option>A</option>, Ändern (<foreignphrase>modify</foreignphrase>): <option>M</option> oder Löschen (<foreignphrase>delete</foreignphrase>): <option>D</option>.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							<literal>__ignore</literal>: Der Inhalt dieser Spalte wird ignoriert. Die kann z.B. verwendet werden, wenn die CSV-Datei leerer Spalten, oder solche mit nicht zu importierenden Daten, enthält.
						</simpara>
					</listitem>
				</itemizedlist>
				Weitere, eigene Interpretationen von Eingabewerten können in einer von <classname>ucsschool.importer.reader.csv_reader.CsvReader</classname> abgeleiteten Klasse (siehe <xref linkend="extending:subclassing"/>) in der Methode <methodname>handle_input()</methodname> erzeugt werden.
				Als Beispiel kann <methodname>handle_input()</methodname> in <classname>ucsschool.importer.legacy.legacy_csv_reader.LegacyCsvReader</classname> dienen, welches für den Import des alten CSV-Dateiformats den Sonderwert <literal>__activate</literal> (neue Benutzer de/aktivieren) hinzufügt.
			</para>
			<para>
				Um Unterstützung für den Import von anderen Dateiformaten als CSV (JSON, XML etc) hinzuzufügen, kann von <classname>ucsschool.importer.reader.base_reader.BaseReader</classname> abgeleitet werden (siehe <xref linkend="extending:subclassing"/>).
			</para>
		</section>

		<section id="configuration:scheme_formatting">
			<title>Formatierungsschema</title>
			<para>
				Es kann wünschenswert &ndash; oder wie im Fall von Benutzername und E-Mail-Adresse notwendig &ndash; sein, Attribute aus den Werten anderer Attribute zu erzeugen.
				Zum Beispiel speichern und exportieren Schulverwaltungssoftwares häufig keine Benutzernamen und E-Mail-Adressen, die zur eingesetzten Infrastruktur passen.
			</para>
			<para>
				Aus diesem Grund unterstützt die Importsoftware die Erzeugung von Attributen mit Hilfe von konfigurierbaren Schemata.
				Das Format ist das gleiche wie das bei den <ulink url="http://docs.software-univention.de/handbuch-4.2.html#users:templates"><citetitle>UCS-Benutzervorlagen</citetitle></ulink> eingesetzte.
				Es existieren dedizierte Konfigurationsschlüssel für die Attribute <property>email</property>, <property>recordUID</property> und <property>username</property>.
				Darüber hinaus können Schemata für beliebige &ucsUDM; Attribute (mit dem Namen des Attributs als Schlüssel) hinterlegt werden.
			</para>
			<para>
				Im folgenden Beispiel würde allen aus den Eingabedaten übernommenen Telefonnummern die Ländervorwahl vorangestellt (und die führende 0 der Städtevorwahl entfernt), sowie die E-Mail-Adresse aus Vor- und Nachname berechnet:
				<programlisting>
{
    "scheme": {
        "email": "&lt;firstname&gt;[0].&lt;lastname&gt;@&lt;maildomain&gt;",
        "recordUID": "&lt;email&gt;",
        "phone": "+49-&lt;phone&gt;[1:]"
    }
}
				</programlisting>
			</para>
		</section>

		<section id="configuration:unique_usernames_and_email">
			<title>Einmalige Benutzernamen und Email-Adressen</title>
			<para>
				Benutzernamen und Email-Adressen müssen in der gesamten Domäne, nicht nur an einer Schule, einmalig sein. Darüber hinaus kann es die Anforderung geben, dass Benutzernamen und Email-Adressen auch "historisch einmalig" sind, also auch dann nicht wiederverwendet werden, wenn die vorherigen Konten bereits lange gelöscht sind.
			</para>
			<para>
				Aus diesem Grund können zur Erzeugung von Benutzernamen und Email-Adressen, über die üblichen Variablen in Formatierungsschema (siehe <xref linkend="configuration:scheme_formatting"/>) hinaus, spezielle Zählervariablen verwendet werden.
				Diese Variablen werden bei ihrer Verwendung automatisch hochgezählt.
				Ihr Wert wird pro Benutzername bzw. Email-Adresse gespeichert.
				Es existieren zwei Variablen, die sich darin unterscheiden wie die ersten Benutzer mit gleichem Benutzernamen bzw. Email-Adresse, benannt werden:
				<itemizedlist>
					<listitem>
						<simpara>
							<literal>[ALWAYSCOUNTER]</literal> ist ein Zähler der bei seiner ersten Verwendung eine 1 einsetzt.
							Benutzernamen für <systemitem class="username">anton</systemitem> wären: <systemitem class="username">anton1</systemitem>, <systemitem class="username">anton2</systemitem>, <systemitem class="username">anton3</systemitem>...
							Analog für <systemitem class="username">anton@dom.ain</systemitem>: <systemitem class="username">anton1@dom.ain</systemitem>, <systemitem class="username">anton2@dom.ain</systemitem>, <systemitem class="username">anton3@dom.ain</systemitem>...
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							<literal>[COUNTER2]</literal> ist ein Zähler der bei seiner ersten Verwendung keine Zahl einsetzt, erst bei seiner zweiten.
							Benutzernamen für <systemitem class="username">anton</systemitem> wären: <systemitem class="username">anton</systemitem>, <systemitem class="username">anton2</systemitem>, <systemitem class="username">anton3</systemitem>...
							Analog für <systemitem class="username">anton@dom.ain</systemitem>: <systemitem class="username">anton@dom.ain</systemitem>, <systemitem class="username">anton2@dom.ain</systemitem>, <systemitem class="username">anton3@dom.ain</systemitem>...
						</simpara>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Im folgenden Beispiel würden für <systemitem class="username">Bea Schmidt</systemitem> die Benutzernamen <systemitem class="username">b.schmidt</systemitem>, <systemitem class="username">b.schmidt2</systemitem>, <systemitem class="username">b.schmidt3</systemitem> sowie Email-Adressen <systemitem class="username">bea.schmidt1@dom.ain</systemitem>, <systemitem class="username">bea.schmidt2@dom.ain</systemitem>, <systemitem class="username">bea.schmidt3@dom.ain</systemitem> erzeugt werden:
				<programlisting>
{
    "scheme": {
        "username": {
            "default": "&lt;:umlauts&gt;&lt;firstname&gt;[0].&lt;lastname&gt;&lt;:lower&gt;[COUNTER2]"
        },
        "email": "&lt;firstname&gt;.&lt;lastname&gt;[ALWAYSCOUNTER]@&lt;maildomain&gt;"
    },
	"maildomain": "dom.ain",
}
				</programlisting>
				Die <literal>[0]</literal> im Beispiel bedeutet, dass nur das erste Zeichen des davor stehenden Attributes genommen wird. Es ist auch möglich Bereiche anzugeben. Weitere Informationen dazu finden sich im Kapitel <ulink url="http://docs.software-univention.de/handbuch-4.2.html#users:templates"><citetitle>Benutzervorlagen</citetitle></ulink> des UCS Handbuchs.
			</para>
			<para>
				Um neue Zählervariablen hinzuzufügen, muss von der Klasse <classname>ucsschool.importer.utils.username_handler.UsernameHandler</classname> abgeleitet und die Methode <methodname>counter_variable_to_function()</methodname> überschrieben werden (siehe <xref linkend="extending:subclassing"/>).
				Um diese neuen Zählervariablen auch für Email-Adressen zu verwenden, muss <classname>ucsschool.importer.utils.username_handler.EmailHandler</classname> von der neuen, abgeleiteten <classname>UsernameHandler</classname> Klasse <emphasis>sowie</emphasis> von <classname>ucsschool.importer.utils.username_handler.EmailHandler</classname> abgeleitet werden.
				Um Zählervariablen <emphasis>nur</emphasis> für Email-Adressen hinzuzufügen muss nur von der Klasse <classname>ucsschool.importer.utils.username_handler.EmailHandler</classname> abgeleitet, und oben beschriebene Methoden überschrieben werden.
			</para>
		</section>

		<section id="configuration:deleting_users">
		<title>Benutzer löschen</title>
			<para>
				Für das Löschen von Benutzern kann in zwei Varianten konfiguriert werden:
				<itemizedlist>
					<listitem>
						<simpara>
							Das Benutzerkonto wird sofort oder später gelöscht, nicht deaktiviert.
						</simpara>
						<simpara>
							Dies entspricht dem Löschen eines Kontos im &ucsUMC;-Modul <guimenu>Benutzer</guimenu> (siehe <biblioref linkend="ucs-handbuch"/>), zum definierten Zeitpunkt.
						</simpara>
						<simpara>
						Diese Variante wird ausgewählt durch das Setzen von <varname>deletion_grace_period:deletion</varname> auf einen Wert kleiner oder gleich dem von <varname>deletion_grace_period:deactivation</varname>. Ist der Wert von <literal>deletion_grace_period:deletion=0</literal>, wird sofort (während des Imports) gelöscht. Ist der Wert größer als <literal>0</literal>, wird ein Verfallsdatum im &ucsUDM;-Attribut <property>ucsschoolPurgeTimestamp</property> gespeichert. Der Benutzer wird erst an diesem Tag durch einen Cron Job gelöscht.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Das Benutzerkonto wird erst deaktiviert und später gelöscht.
						</simpara>
						<simpara>
							Dies entspricht dem Deaktivieren oder Setzen eines Kontoablaufdatums im &ucsUMC;-Modul <guimenu>Benutzer</guimenu> und späteren Löschens in selbigem.
							Der Benutzer wird zuerst deaktiviert (kann sich nicht mehr einloggen), aber erst zu dem gesetzten Datum gelöscht. Bis zum finalen Löschen kann das Benutzerkonto noch reaktiviert werden, sollte es durch einen Import wieder "angelegt" werden.
						</simpara>
						<simpara>
							Diese Variante wird ausgewählt durch das Setzen von <varname>deletion_grace_period:deletion</varname> auf einen Wert größer dem von <varname>deletion_grace_period:deactivation</varname>. Ist der Wert von <literal>deletion_grace_period:deactivation=0</literal>, wird der Account sofort (während des Imports) deaktiviert. Ist der Wert größer als <literal>0</literal>, wird ein Verfallsdatum im &ucsUDM;-Attribut <property>user_expiry</property> gespeichert. Der Benutzer kann sich ab diesem Tag nicht mehr anmelden. Der Wert von <varname>deletion_grace_period:deletion</varname> wird wie in der ersten Variante beschrieben im &ucsUDM;-Attribut <property>ucsschoolPurgeTimestamp</property> gespeichert und die Löschung später durch einen Cron Job durchgeführt.
						</simpara>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Um eine der Löschvarianten zu ändern oder neue hinzuzufügen, muss von der Klasse <classname>ucsschool.importer.mass_import.user_import.UserImport</classname> abgeleitet und die Methode <methodname>do_delete()</methodname> überschrieben werden (siehe <xref linkend="extending:subclassing"/>).
			</para>
		</section>
	</chapter>

		<chapter id="school_change">
	<title>Schulwechsel</title>
		<para>
			Bei einem Schulwechsel verlässt ein Schüler oder Lehrer seine ursprüngliche Schule A und wird an einer anderen Schule B aufgenommen.
			Hierbei sind drei Szenarien denkbar:
			<itemizedlist>
				<listitem>
					<simpara>
						Schule A und Schule B werden vom gleichen Quellverzeichnis abgedeckt und gemeinsam verwaltet.
						D.h. die für den Benutzer hinterlegte Schule ändert sich in einem Schritt von Schule A auf Schule B.
						Die Importsoftware kann das Benutzerobjekt verschieben, ohne dass sich Daten wie Benutzername, User-ID, Telefonnummer oder Passwort ändern.
					</simpara>
				</listitem>
				<listitem>
					<para>
						Schule A und Schule B werden vom gleichen Quellverzeichnis abgedeckt, die beiden Schulverwaltungen pflegen die Daten ihrer Schüler oder Lehrer jedoch unabhängig voneinander.
						Der Schulwechsel findet also in zwei Schritten statt.
						Es können zwei Szenarien auftreten:
						<itemizedlist>
							<listitem>
								<simpara>
									Der Benutzer wird an Schule A entfernt und erst später an Schule B neu aufgenommen.
									Wurde das Benutzerkonto gelöscht und nicht deaktiviert, verliert der Benutzer alle Benutzerdaten und erhält ein komplett neues Benutzerkonto inkl. Benutzernamen, User-ID, Passwort etc.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									Der Benutzer wird an Schule B aufgenommen, bevor er an Schule A entfernt wird.
									Das Benutzerkonto wird kurzfristig an zwei Schulen repliziert, die Daten bleiben während der gesamten Zeit (auch nach Entfernen von Schule A) erhalten.
								</simpara>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<simpara>
						Schule A und Schule B werden von unterschiedlichen Quellverzeichnissen abgedeckt.
						Der Benutzer wird in Schule A entfernt und vorher oder später in Schule B neu angelegt.
						Der Benutzer erhält dann einen neuen Benutzernamen, User-ID, Passwort etc.
						Das Übernehmen des Benutzerkontos ist nicht ohne weiteres möglich.
					</simpara>
				</listitem>
			</itemizedlist>
		</para>
	</chapter>

	<chapter id="school_year_change">
	<title>Schuljahreswechsel</title>
		<para>
			Der Schuljahreswechsel erfolgt in drei Schritten:
			<orderedlist>
				<listitem>
					<simpara>
						In der Schulverwaltungssoftware findet der Schuljahreswechsel statt.
						Anschließend wird ein Export der Benutzer aus der Schulverwaltungssoftware gemacht.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Die Klassen der Schüler die die Schule verlassen, werden im &ucsUMC;-Modul <guimenu>Klassen</guimenu> gelöscht.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Durchführung des Imports der zuvor Exportierten Daten.
					</simpara>
				</listitem>
			</orderedlist>
		</para>
	</chapter>

	<chapter id="ou_spanning_account">
	<title>Schulübergreifende Benutzerkonten</title>
		<para>
			Seit &ucsUAS; 4.1 R2 werden schulübergreifende Benutzerkonten unterstützt.
			Ein Benutzerobjekt existiert im LDAP-Verzeichnis nur einmal: an seiner primären Schule (Attribut <property>school</property>).
			An weitere, festgelegte Schulen (Attribut <property>schools</property>) wird nur ein Ausschnitt des LDAP-Verzeichnisses seiner primären Schule repliziert: sein Benutzerobjekt und die Standardgruppen.
			Verlässt der Benutzer die Schule (durch Entfernen aus dem Attribut <property>schools</property>), so wird sein Benutzerobjekt dort gelöscht und nicht mehr dorthin repliziert.
			Bei der Verwendung von schulübergreifenden Benutzerkonten gilt es einige Dinge zu beachten.
		</para>
		<para>
		</para>
		<para>
			Der Klassenarbeitsmodus und die Materialverteilung arbeiten grundsätzlich so, dass sie auf dem Schulserver an dem sie veranlasst wurden, die hochgeladenen Dateien in die Heimatverzeichnisse der betroffenen Benutzer kopieren. Befindet sich ein Heimatverzeichnis nicht auf dem Server, scheitert dies.
		</para>
		<para>
			Windows-Clients verwenden das LDAP-Attribut <property>homeDirectory</property> (LDAP-Attribut <property>sambaHomePath</property> bzw. &ucsUDM;-Attribut <property>sambahome</property>) um beim Einloggen das Netzwerklaufwerk mit den Dokumenten des Benutzers einzubinden.
			Wenn die primäre Schule eines Benutzers eine andere ist, als die, an der er gerade eine Klassenarbeit schreiben soll, so existiert sein Heimatverzeichnis dort unter Umständen nicht.
		</para>
		<para>
			Es existieren drei Varianten des Umgangs mit der &ucsUDM;-Attribut <property>sambahome</property>, mit folgenden Vor- und Nachteilen:
			<orderedlist>
				<listitem>
					<para>
                        <property>sambahome</property> wird regulär durch das Import-Skript gesetzt und nicht manuell verändert.
						<property>sambahome</property> ist dann immer ein Verzeichnis auf dem Schulserver der primären Schule des jeweiligen Benutzers.
						<itemizedlist>
							<listitem>
								<simpara>
									pro: Es existiert genau ein Heimatverzeichnis auf einem Server für alle Clients der Domäne (egal an welcher Schule).
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									contra: Klassenarbeitsmodus und Materialverteilung funktionieren nicht an anderen Schulen als der primären. Beim regulären Arbeiten gibt es ein hohes Datenaufkommen zwischen den Schulen.
								</simpara>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						<property>sambahome</property> wird durch das Import-Skript für alle auf einen (per &ucsUCR;) festgesetzten, zentralen, Server gesetzt.
						<itemizedlist>
							<listitem>
								<simpara>
									pro: wie bei 1.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									contra: wie bei 1.
								</simpara>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						<property>sambahome</property> wird durch das Import-Skript auf einen Server mit einem Alias-Namen gesetzt.
						Je nach dem an welcher Schule sich der Benutzer befindet, bekommt er vom DNS-Server eine andere IP-Adresse für den gleichen Servernamen geliefert.
						<itemizedlist>
							<listitem>
								<simpara>
									pro: Klassenarbeitsmodus und Materialverteilung funktionieren, an der jeweiligen Schule an der sie stattfinden, für alle Benutzer - egal ob es ihre primäre Schule ist oder nicht.
									Kein Datenverkehr zwischen Schulen.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									contra: Es wird an jeder Schule eines Benutzers ein eigenes Heimatverzeichnis für ihn angelegt.
									Einmaliger Installationsaufwand: An jeder Schule müssen ein paar &ucsUCR;-Variablen eingestellt werden.
								</simpara>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
			</orderedlist>
		</para>
		<para>
			Es folgt eine Anleitung zur Einrichtung der dritten Variante.
		</para>
		<section id="ou_spanning_account:sambahome">
			<title>Schulspezifisches <property>sambahome</property></title>
			<para>
				Die folgenden Befehle müssen, mit angepassten Hostnamen und IP-Adressen, auf jedem Schulserver ausgeführt werden:
				<programlisting>
# UCR Variablen verfügbar machen
eval "$(ucr shell)"

# Name (Alias) des Servers auf dem das Heimatverzeichnis liegt
ucr set ucsschool/import/set/sambahome=schoolserver

# DNS-Eintrag schoolserver.$domainname -> IP-Adresse des *jeweiligen* Schulservers
ucr set "connector/s4/mapping/dns/host_record/schoolserver.$domainname/static/ipv4"=172.16.3.12

# DNS-Eintrag aktivieren
invoke-rc.d univention-s4-connector restart
				</programlisting>
			</para>
			<para>
				Folgendes muss auf dem DC Master ausgeführt werden:
				<programlisting>
# Name (Alias) des Servers auf dem das Heimatverzeichnis liegt (wird vom Import ausgewertet)
ucr set ucsschool/import/set/sambahome=schoolserver

# DNS Forward-Eintrag einrichten (school.local durch korrekte Domäne ersetzen,
# IP-Adresse eines zentralen Server, z.B. des DC Master, verwenden)
udm dns/host_record create \
    --superordinate "zoneName=school.local,cn=dns,$ldap_base" \
    --set name=schoolserver \
    --set a=172.16.1.1
				</programlisting>
			</para>
			<para>
				Der Befehl <command>host schoolserver</command> sollte nun auf allen Schulservern die IP-Adresse des jeweiligen Schulservers liefern.
				Mit <command>nslookup schoolserver</command> können die gleiche DNS-Anfrage komfortabel an verschiedene DNS-Server geschickt werden.
			</para>
		  </section>
	</chapter>

	<chapter id="extending">
	<title>Erweiterung um neue Funktionalität</title>
		<para>
			Die &ucsUAS; Importsoftware ist so geschrieben worden, dass ihre Funktionalität möglichst einfach und gleichzeitig umfangreich veränderbar und erweiterbar ist.
			Dazu stehen zwei Methoden zur Verfügung:
				<itemizedlist>
					<listitem>
						<simpara>
							Das Ausführen von Aktionen zu bestimmten Zeitpunkten mit der Hilfe von Python-Hooks.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Die Veränderung der Importsoftware durch das Überschreiben von Teilen des Programmcodes.
						</simpara>
					</listitem>
				</itemizedlist>
		</para>

		<section id="extending:import_user_class">
			<title>Die <classname>ImportUser</classname> Klasse</title>
			<para>
				Die Klasse <classname>ImportUser</classname> wird verwendet um Daten von eingelesenen oder zu ändernden Benutzern zu speichern. An Objekten der <classname>ImportUser</classname> Klasse können folgende Attribute gesetzt werden:
				<table id="table:import_user">
					<title>Attribute der ImportUser Klasse</title>
					<tgroup cols="3">
						<colspec colnum="1" colname="key" colwidth="2*"/>
						<colspec colnum="2" colname="type" colwidth="1*"/>
						<colspec colnum="3" colname="description" colwidth="7*"/>
						<thead>
							<row>
								<entry>Attribut</entry>
								<entry>Typ</entry>
								<entry>Beschreibung</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><varname>name</varname></entry>
								<entry>string</entry>
								<entry>Benutzername</entry>
							</row>
							<row>
								<entry><varname>school</varname></entry>
								<entry>string</entry>
								<entry>Primäre Schule des Benutzers (Position des Objektes im LDAP)</entry>
							</row>
							<row>
								<entry id="extending:import_user_class:importuser:schools"><varname>schools</varname></entry>
								<entry>string / liste</entry>
								<entry>Alle Schulen des Benutzers inkl. der primären Schule, als ein kommaseparierter String oder als Liste von Strings.</entry>
							</row>
							<row>
								<entry><varname>firstname</varname></entry>
								<entry>string</entry>
								<entry>Vorname</entry>
							</row>
							<row>
								<entry><varname>lastname</varname></entry>
								<entry>string</entry>
								<entry>Nachname</entry>
							</row>
							<row>
								<entry><varname>birthday</varname></entry>
								<entry>string</entry>
								<entry>Geburtsdatum im Format <literal>JJJJ-MM-TT</literal></entry>
							</row>
							<row>
								<entry><varname>email</varname></entry>
								<entry>string</entry>
								<entry>E-Mail-Adresse</entry>
							</row>
							<row>
								<entry><varname>password</varname></entry>
								<entry>string</entry>
								<entry>Passwort (wird für neue Benutzer automatisch erzeugt, wenn nicht in den Eingabedaten vorhanden).</entry>
							</row>
							<row>
								<entry><varname>disabled</varname></entry>
								<entry>boolean</entry>
								<entry>Ob ein neuer Benutzer deaktiviert erzeugt werden soll.</entry>
							</row>
							<row>
								<entry><varname>school_classes</varname></entry>
								<entry>string / object</entry>
								<entry><simpara>Klassen in denen der Benutzer ist.</simpara><simpara>Als String im Format <literal>schule1-1A,schule1-2B,schule2-1A</literal> oder als Python <wordasword>dictionary</wordasword>: <literal>{"schule1": ["1A", "2B"], "schule2": ["1A"]}</literal>.</simpara><simpara>Es können Klassen aus mehreren Schulen aufgelistet werden; diese Schulen müssen alle in <link linkend="extending:import_user_class:importuser:schools"><varname>schools</varname></link> auftauchen. Wenn <varname>school_classes</varname> leer ist, werden bestehende Klassen nicht verändert.</simpara></entry>
							</row>
							<row>
								<entry><varname>source_uid</varname></entry>
								<entry>string</entry>
								<entry>Kennzeichnung der Datenquelle</entry>
							</row>
							<row>
								<entry><varname>record_uid</varname></entry>
								<entry>string</entry>
								<entry>ID des Benutzers in der Datenquelle</entry>
							</row>
							<row>
								<entry><varname>udm_properties</varname></entry>
								<entry>object</entry>
								<entry><simpara>Alle anderen &ucsUDM; Attribute die in den Eingabedaten enthalten waren, werden in dieses Python <wordasword>dictionary</wordasword> gespeichert.</simpara><simpara>Oben stehende Attribute und ihre <wordasword>&ucsUDM;-Pendants</wordasword> (<varname>name</varname> &rarr; <varname>username</varname>, <varname>email</varname> &rarr; <varname>mailPrimaryAddress</varname>) sind hier nicht erlaubt.</simpara></entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				Weitere interessante Attribute, die jedoch nur gelesen und nicht modifiziert werden sollten, sind:
				<table>
					<title>Attribute der <classname>ImportUser</classname> Klasse (nur lesen)</title>
					<tgroup cols="3">
						<colspec colnum="1" colname="key" colwidth="2*"/>
						<colspec colnum="2" colname="type" colwidth="1*"/>
						<colspec colnum="3" colname="description" colwidth="7*"/>
						<thead>
							<row>
								<entry>Attribut</entry>
								<entry>Typ</entry>
								<entry>Beschreibung</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><varname>dn</varname></entry>
								<entry>string</entry>
								<entry>DN des Benutzer-Objekts im LDAP, wenn es jetzt gespeichert werden würde.</entry>
							</row>
							<row>
								<entry><varname>entry_count</varname></entry>
								<entry>int</entry>
								<entry>Zeile in CSV-Datei, aus der Daten des Benutzers stammen. Ist 0, wenn dies nicht zutrifft.</entry>
							</row>
							<row>
								<entry><varname>input_data</varname></entry>
								<entry>list</entry>
								<entry>Unveränderte Eingabedaten aus der CSV-Datei, bereits zu Elementen einer Liste aufgeteilt.</entry>
							</row>
							<row>
								<entry><varname>ucr</varname></entry>
								<entry>object</entry>
								<entry>Eine &ucsUCR;-Instanz zum Auslesen von &ucsUCR;-Einstellungen.</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
			</para>
		  </section>

		<section id="extending:hooks">
			<title>Hooks</title>
			<para>
				<ulink url="https://de.wikipedia.org/wiki/Hook_(Informatik)"><citetitle>Hooks</citetitle></ulink> sind Stellen im Programmcode, an die zusätzlicher Code "gehängt" werden kann.
				Für den Benutzerimport sind acht Stellen vorgesehen: jeweils vor und nach dem Anlegen, Ändern, Löschen oder Verschieben von Benutzern.
			</para>
			<para>
				Zur Nutzung der Hook-Funktionalität muss eine eigene Python-Klasse erstellt werden, die von <classname>ucsschool.importer.utils.user_pyhook.UserPyHook</classname> ableitet.
				In der Klasse können Methoden <methodname>pre_create()</methodname>, <methodname>post_create()</methodname>, etc. definiert werden, welche zum jeweiligen Zeitpunkt ausgeführt werden.
				Der Name der Datei mit der eigenen Klasse muss auf <filename>.py</filename> enden und im Verzeichnis <filename class="directory">/usr/share/ucs-school-import/pyhooks</filename> abgespeichert werden.
			</para>
			<note>
				<simpara>
					Der Quellcode der Klasse <classname>UserPyHook</classname> ist zu finden in <filename>/usr/lib/pymodules/python2.7/ucsschool/importer/utils/user_pyhook.py</filename>. In ihm sind alle Methoden und Signaturen dokumentiert.
				</simpara>
			</note>
			<para>
				Die Methoden der Hook-Klasse bekommen als Argument das Benutzerobjekt übergeben, das aus dem LDAP geladen wurde bzw. im LDAP gespeichert werden soll.
				Veränderungen an diesem Objekt werden bei dessen Abspeicherung direkt ins LDAP übernommen.
			</para>
			<para>
				Die Klasse definiert ein <wordasword>dictionary</wordasword> <literal>priority</literal> mit dessen Hilfe eine Reihenfolge definiert werden kann, sollten mehrere Hook-Klassen mit zum Einsatz kommen, die die gleichen Methoden definieren.
				Die Namen der Methoden die ausgeführt werden sollen sind die Schlüssel, Methoden mit höheren Zahlen werden zu erst ausgeführt.
				Ist der Wert <literal>None</literal>, wird die Methode deaktiviert.
			</para>
			<para>
				Zur Erstellung einer eigenen Hook-Klasse kann das Beispiel in <filename>/usr/share/doc/ucs-school-import/hook_example.py</filename> kopiert und angepasst werden.
				Alle Funktionen die nicht ausgeführt werden sollen, sollten entweder gelöscht oder deaktiviert werden (indem ihr Wert in <literal>priority</literal> auf <literal>None</literal> gesetzt wird).
				Das könnte Beispielsweise so aussehen:
				<programlisting>
import datetime
import shutil

from ucsschool.importer.utils.user_pyhook import UserPyHook

class MyHook(UserPyHook):
    priority = {
        "pre_create": 1,
        "post_create": None,
        "pre_remove": 1
    }

    def pre_create(self, user):
        if user.birthday:
            bday = datetime.datetime.strptime(user.birthday,
                                              "%Y-%m-%d").date()
            if bday == datetime.date.today():
                self.logger.info("%s has birthday.", user)
                user.udm_properties["description"] = "Herzlichen \
                                                      Glückwunsch"

    def post_create(self, user):
        # Diese Function ist deaktiviert.
        self.logger.info("Running a post_create hook for %s.", user)

    def pre_remove(self, user):
        # backup users home directory
        self.logger.info("Backing up home directory of %s.", user)
        user_udm = user.get_udm_object(self.lo)
        homedir = user_udm["unixhome"]
        shutil.copy2(homedir, "/var/backup/{}".format(user.name))
				</programlisting>
			</para>
			<para>
				<itemizedlist>
					<listitem>
						<simpara>
							In <methodname>pre_create()</methodname> wird bei einem neuen Benutzer ein Gruß am Benutzerobjekt gespeichert, wenn er Geburtstag hat.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Die <methodname>post_create()</methodname> Funktion ist durch das <literal>None</literal> in <literal>priority</literal> deaktiviert.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							In <methodname>pre_remove()</methodname> wird ein Backup des Heimatverzeichnisses des Benutzers gemacht, bevor er gelöscht wird.
						</simpara>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				In <methodname>pre_create()</methodname> wird in <varname>udm_properties</varname> an den Schlüssel description der Wert <literal>Herzlichen Glückwunsch</literal> geschrieben.
			Das explizite Abspeichern des <literal>user</literal> Objektes ist in dieser Funktion nicht nötig, da dies ja beim auf den Hook folgenden <methodname>create</methodname> geschieht.
			</para>
			<para>
				In der Funktion wird außerdem mit <methodname>self.logger.info()</methodname> ein Text zu Protokoll gegeben.
				Es handelt sich bei <property>self.logger</property> um eine Instanz eines <ulink url="https://docs.python.org/2/library/logging.html"><citetitle>Python <classname>logging</classname></citetitle></ulink> Objekts.
			</para>
			<para>
				In <methodname>pre_remove()</methodname> wird das Heimatverzeichnis des Benutzers benötigt.
				Da dies nicht eines der direkt am Objekt stehenden Daten ist (siehe <xref linkend="extending:import_user_class"/>), muss zuerst das gesamte Benutzerobjekt aus dem LDAP geladen werden.
				Dies tut <methodname>user.get_udm_object()</methodname>, welches als Argument ein LDAP-Verbindungsobjekt erwartet.
				Dieses ist im <wordasword>Hook-Objekt</wordasword> an <property>self.lo</property> gespeichert.
			</para>
			<caution>
				<para>
					Falls das Benutzerobjekt in einem <foreignphrase>post-Hook</foreignphrase> geändert werden soll, so ist es möglich <methodname>user.modify_without_hooks()</methodname> auszuführen, aber generell sollte ein erneutes Modifizieren <emphasis>nach</emphasis> dem Speichern vermieden werden.
				</para>
				<para>
					Die Methoden <methodname>create()</methodname>, <methodname>modify()</methodname> und <methodname>remove()</methodname> des Benutzerobjekts sollten von Hook-Methoden nicht ausgeführt werden, da dies zu einer Rekursion führen kann.
				</para>
			</caution>
		  </section>

		<section id="extending:subclassing">
			<title><foreignphrase>Subclassing</foreignphrase></title>
			<para>
				Hooks erlauben das Ausführen von neuem Code zu bestimmten Zeitpunkten.
				Sie erlauben aber nicht bestehenden Code zu verändern.
				In einer objektorientierten Sprache wie Python wird dies üblicherweise getan, indem eine Klasse modifiziert wird.
				Soll für einen bestimmten Fall nur ein Teil der Klasse verändert werden, wird von ihr abgeleitet und nur dieser Teil verändert, der unveränderte Teil wird geerbt.
			</para>
			<para>
				Folgendes Beispiel zeigt, wie der Klasse, welche die historisch einmaligen Benutzernamen erzeugt, eine weitere Variable hinzugefügt werden kann.
				Ein weiteres Beispiel ist in <filename>/usr/share/doc/ucs-school-import/subclassing_example.py</filename> zu finden.
			</para>
			<programlisting>
from ucsschool.importer.utils.username_handler import UsernameHandler

class MyUsernameHandler(UsernameHandler):
    @property
    def counter_variable_to_function(self):
        name_function_mapping = super(MyUsernameHandler, self).counter_variable_to_function
        name_function_mapping["[ALWAYSWITHZEROS]"] = self.always_counter_with_zeros
        return name_function_mapping

    def always_counter_with_zeros(self, name_base):
        number_str = self.always_counter(name_base)
        number_int = int(number_str)
        new_number_str = "{:04}".format(number_int)
        return new_number_str
			</programlisting>
			<para>
				In <methodname>counter_variable_to_function()</methodname> wird den existierenden beiden Variablen eine weitere hinzugefügt und auf die neue Funktion verwiesen.
				<methodname>always_counter_with_zeros()</methodname> verwendet <methodname>always_counter()</methodname> zur Erzeugung der nächsten freien Zahl, schreibt diese aber dann so um, dass sie immer vier Stellen lang ist (der Anfang wird mit Nullen aufgefüllt).
			</para>
			<para>
				Wird die Klasse unter <filename class="directory">/usr/local/lib/python2.7/dist-packages/usernames_with_zeros.py</filename> abgespeichert, so kann sie unter Python als <classname>usernames_with_zeros.MyUsernameHandler</classname> verwendet werden.
				Zuvor muss das Verzeichnis angelegt werden:
				<programlisting>
mkdir -p /usr/local/lib/python2.7/dist-packages
				</programlisting>
			</para>
			<para>
				Ob Python die Klasse findet, lässt sich testen mit:
				<programlisting>
python -c 'from usernames_with_zeros import MyUsernameHandler'
				</programlisting>
				(Es sollte keine Ausgabe geben.)
			</para>
			<para>
				Die neue Funktionalität lässt sich testen mit:
				<programlisting>
# python
>>> from usernames_with_zeros import MyUsernameHandler
>>> print MyUsernameHandler(15).format_username("Anton[ALWAYSCOUNTER]")
Anton1
>>> print MyUsernameHandler(15).format_username("Anton[ALWAYSWITHZEROS]")
Anton0002
>>> print MyUsernameHandler(15).format_username("Anton[ALWAYSWITHZEROS]")
Anton0003
>>> exit()
				</programlisting>
			</para>
			<para>
				Es gibt jetzt eine neue Klasse mit der neuen Funktionalität.
				Die Importsoftware muss nun noch dazu gebracht werden, diese neue, ihr nicht bekannte Klasse zu verwenden.
			</para>

			<section id="extending:subclassing:abstract_factory">
				<title><foreignphrase>Abstract Factory</foreignphrase></title>
				<para>
					Die Architektur der Importsoftware ist als <ulink url="https://de.wikipedia.org/wiki/Abstrakte_Fabrik"><citetitle>Abstrakte Fabrik (<foreignphrase>Abstract Factory</foreignphrase>)</citetitle></ulink> implementiert.
					In ihr wird die Erzeugung von Objekten zentralisiert.
					Sie zeichnet sich u.a. dadurch aus, dass sie erlaubt das Austauschen mehrerer Komponenten einer Software konsistent zu halten.
					Im Fall der Importsoftware ist die <foreignphrase>abstract factory</foreignphrase> jedoch nicht Abstrakt, alle Methoden wurden implementiert.
				</para>
				<para>
					An allen Stellen der Importsoftware die z.B. mit dem Einlesen von CSV-Dateien zu tun haben, wird nicht die Klasse <classname>ucsschool.importer.reader.csv_reader.CsvReader</classname> direkt instantiiert, sondern es wird von der eingesetzten <property>factory</property> eine Instanz verlangt (<methodname>factory.make_reader()</methodname>) und verwendet.
					Welche Klasse dem verwendeten Objekt zugrunde liegt ist nicht bekannt, sie muss nur die Methoden der ersetzten Klasse mit der gleichen Signatur implementieren.
					Auf diese Art könnte z.B. der <classname>CSV-Reader</classname> durch einen <classname>JSON-Reader</classname> ersetzt werden.
					Alles was dann zu tun bleibt, ist, die <property>factory</property> zu verändern.
					Dies kann auf zwei Arten geschehen:
				</para>
				<para>
				<itemizedlist>
					<listitem>
						<simpara>
							Überschreiben einzelner Methoden der <classname>DefaultUserImportFactory</classname> Klasse.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Ersetzen von <classname>DefaultUserImportFactory</classname> durch eine eigene Klasse.
						</simpara>
					</listitem>
				</itemizedlist>
				</para>
				<para>
					Welche Methode gewählt wird, hängt davon ab ob die Anpassungen nur punktuell sind, oder ob es sich um ein größeres Umschreiben der Importsoftware handelt.
				</para>
			</section>

			<section id="extending:subclassing:overwriting_factory_method">
				<title>Überschreiben einer Methode</title>
				<para>
					Es ist möglich die Methoden der <classname>DefaultUserImportFactory</classname> Klasse einzeln zu überschreiben, ohne ihren Code zu ändern.
					Damit die <property>factory</property> Objekte der <classname>MyUsernameHandler</classname> Klasse aus dem obigen Beispiel beim Aufruf von <methodname>make_username_handler()</methodname> liefert, muss in die Konfiguration folgendes eingetragen werden (siehe Konfigurationsoption <link linkend="configuration:json_format:userimport:classes"><option>classes</option></link>):
					<programlisting>
{
    "classes": {
        "username_handler": "usernames_with_zeros.MyUsernameHandler"
    }
}
					</programlisting>
				</para>
			  </section>

			<section id="extending:subclassing:replacing_factory_class">
				<title>Ersetzen durch eigene Klasse</title>
				<para>
					Sollen umfangreichere Änderungen an der Importsoftware durchgeführt werden, kann von <classname>ucsschool.importer.default_user_import_factory.DefaultUserImportFactory</classname> abgeleitet und ihre Methoden ersetzt werden.
					In der Konfigurationsdatei kann die zu nutzende <property>factory</property>-Klasse über den Schlüssel <option>factory</option> als voller Python-Pfad angegeben werden.
				</para>
				<para>
					Obiges Beispiel lässt sich anstatt in der Konfiguration <option>classes:username_handler</option> zu setzen auch so lösen:
					<programlisting>
from ucsschool.importer.default_user_import_factory import DefaultUserImportFactory
from usernames_with_zeros import MyUsernameHandler

class MyUserImportFactory(DefaultUserImportFactory):
    def make_username_handler(self, max_length):
        return MyUsernameHandler(max_length)
					</programlisting>
				</para>
				<para>
					Wird diese Datei nun als <filename>/usr/local/lib/python2.7/dist-packages/my_userimport_factory.py</filename> abgespeichert, so kann sie in der Konfiguration zur Verwendung als <property>factory</property> für die Importsoftware folgendermaßen aktiviert werden:
					<programlisting>
{
    "factory": "my_userimport_factory.MyUserImportFactory"
}
					</programlisting>
				</para>
				<para>
					Der nächste Importvorgang lädt nun anstelle der <classname>DefaultUserImportFactory</classname> die <classname>MyUserImportFactory</classname> und wenn in der Importsoftware ein Objekt zur Erzeugung von Benutzernamen angefordert wird, so wird die neue Klasse entscheiden, das eines vom Typ <classname>MyUsernameHandler</classname> geliefert wird.
				</para>
			  </section>
		  </section>
	</chapter>
</book>
